import { ScaffoldUseCase } from './scaffold.use-case';
import { ScaffoldRequest, ScaffoldPlanResponse } from './scaffold.types';
import { FileSystemPort } from '../../ports/filesystem.port';
import { ArchSymbol } from '../../../domain/entities/arch-symbol';
import { ScaffoldOperation, OperationType } from '../../../domain/value-objects/scaffold-operation';
import { ScaffoldPlan } from '../../../domain/value-objects/scaffold-plan';
import { ScaffoldResult, OperationResult } from '../../../domain/value-objects/scaffold-result';

export class ScaffoldService implements ScaffoldUseCase {
  constructor(
    private readonly fsPort: FileSystemPort,
  ) {}

  plan(request: ScaffoldRequest): ScaffoldPlanResponse {
    const { instanceSymbol, kindName, projectRoot } = request;
    const operations: ScaffoldOperation[] = [];
    const warnings: string[] = [];

    // Create root directory for the instance
    if (instanceSymbol.declaredLocation) {
      const rootPath = this.resolvePath(instanceSymbol.declaredLocation, projectRoot);
      operations.push(ScaffoldOperation.createDirectory(rootPath));
    } else {
      warnings.push(`Instance '${instanceSymbol.name}' has no declared location.`);
    }

    // Create directories and stubs for each member
    const members = instanceSymbol.getAllMembers();
    if (members.length === 0) {
      warnings.push(`Instance '${instanceSymbol.name}' has no members to scaffold.`);
    }

    for (const member of members) {
      this.planMember(member, projectRoot, operations, warnings);
    }

    const plan = new ScaffoldPlan(operations, instanceSymbol.name, kindName);
    return { plan, warnings };
  }

  apply(plan: ScaffoldPlan): ScaffoldResult {
    const results: OperationResult[] = [];

    for (const op of plan.operations) {
      try {
        switch (op.type) {
          case OperationType.CreateDirectory:
            if (this.fsPort.directoryExists(op.path)) {
              results.push(OperationResult.skipped(op, 'already exists'));
            } else {
              this.fsPort.createDirectory(op.path);
              results.push(OperationResult.success(op));
            }
            break;

          case OperationType.CreateFile:
            if (this.fsPort.fileExists(op.path)) {
              results.push(OperationResult.skipped(op, 'already exists'));
            } else {
              this.fsPort.writeFile(op.path, op.content ?? '');
              results.push(OperationResult.success(op));
            }
            break;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        results.push(OperationResult.failure(op, message));
      }
    }

    return new ScaffoldResult(results);
  }

  private planMember(
    member: ArchSymbol,
    projectRoot: string,
    operations: ScaffoldOperation[],
    warnings: string[],
  ): void {
    if (!member.declaredLocation) {
      warnings.push(`Member '${member.name}' has no declared location.`);
      return;
    }

    const dirPath = this.resolvePath(member.declaredLocation, projectRoot);
    operations.push(ScaffoldOperation.createDirectory(dirPath));
    operations.push(ScaffoldOperation.createFile(
      this.fsPort.resolvePath(dirPath, 'index.ts'),
      this.generateStubContent(member.name),
    ));

    // Recurse into sub-members
    for (const subMember of member.getAllMembers()) {
      this.planMember(subMember, projectRoot, operations, warnings);
    }
  }

  private generateStubContent(memberName: string): string {
    return `// ${memberName} layer\n// Generated by KindScript\n\nexport {};\n`;
  }

  private resolvePath(relativePath: string, projectRoot: string): string {
    return this.fsPort.resolvePath(projectRoot, relativePath);
  }
}
