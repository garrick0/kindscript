import { ScaffoldService } from '../../src/application/use-cases/scaffold/scaffold.service';
import { MockFileSystemAdapter } from '../../src/infrastructure/adapters/testing/mock-filesystem.adapter';
import { ArchSymbol } from '../../src/domain/entities/arch-symbol';
import { ArchSymbolKind } from '../../src/domain/types/arch-symbol-kind';
import { OperationType } from '../../src/domain/value-objects/scaffold-operation';

function makeInstance(
  name: string,
  location: string,
  members: Array<{ name: string; location: string; subMembers?: Array<{ name: string; location: string }> }>,
): ArchSymbol {
  const memberMap = new Map<string, ArchSymbol>();
  for (const m of members) {
    const subMap = new Map<string, ArchSymbol>();
    if (m.subMembers) {
      for (const sm of m.subMembers) {
        subMap.set(sm.name, new ArchSymbol(sm.name, ArchSymbolKind.Member, sm.location));
      }
    }
    memberMap.set(m.name, new ArchSymbol(m.name, ArchSymbolKind.Member, m.location, subMap));
  }
  return new ArchSymbol(name, ArchSymbolKind.Instance, location, memberMap);
}

describe('ScaffoldService', () => {
  let mockFS: MockFileSystemAdapter;
  let service: ScaffoldService;

  beforeEach(() => {
    mockFS = new MockFileSystemAdapter();
    service = new ScaffoldService(mockFS);
  });

  afterEach(() => {
    mockFS.reset();
  });

  describe('plan()', () => {
    it('plans correct operations for a 3-layer instance', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
        { name: 'application', location: 'src/application' },
        { name: 'infrastructure', location: 'src/infrastructure' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      // 1 root dir + 3 layer dirs + 3 index.ts files = 7 operations
      expect(plan.operations).toHaveLength(7);
      expect(plan.directoryCount).toBe(4);
      expect(plan.fileCount).toBe(3);
      expect(plan.instanceName).toBe('app');
    });

    it('plans correct operations for a 2-layer instance', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
        { name: 'adapters', location: 'src/adapters' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      expect(plan.operations).toHaveLength(5);
      expect(plan.directoryCount).toBe(3);
      expect(plan.fileCount).toBe(2);
    });

    it('resolves relative paths against projectRoot', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      const paths = plan.operations.map(o => o.path);
      expect(paths).toContain('/project/src');
      expect(paths).toContain('/project/src/domain');
      expect(paths).toContain('/project/src/domain/index.ts');
    });

    it('generates correct stub content', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      const fileOps = plan.operations.filter(o => o.type === OperationType.CreateFile);
      expect(fileOps).toHaveLength(1);
      expect(fileOps[0].content).toContain('// domain layer');
      expect(fileOps[0].content).toContain('// Generated by KindScript');
      expect(fileOps[0].content).toContain('export {};');
    });

    it('handles nested members (sub-layers)', () => {
      const instance = makeInstance('app', 'src', [
        {
          name: 'domain',
          location: 'src/domain',
          subMembers: [
            { name: 'entities', location: 'src/domain/entities' },
            { name: 'ports', location: 'src/domain/ports' },
          ],
        },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      const paths = plan.operations.map(o => o.path);
      expect(paths).toContain('/project/src/domain/entities');
      expect(paths).toContain('/project/src/domain/entities/index.ts');
      expect(paths).toContain('/project/src/domain/ports');
      expect(paths).toContain('/project/src/domain/ports/index.ts');
    });

    it('warns when member has no declaredLocation', () => {
      const memberMap = new Map<string, ArchSymbol>();
      memberMap.set('domain', new ArchSymbol('domain', ArchSymbolKind.Member, undefined));
      const instance = new ArchSymbol('app', ArchSymbolKind.Instance, 'src', memberMap);

      const { warnings } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      expect(warnings).toContain("Member 'domain' has no declared location.");
    });

    it('returns plan with warning for instance with no members', () => {
      const instance = new ArchSymbol('app', ArchSymbolKind.Instance, 'src');

      const { plan, warnings } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      // Root dir only
      expect(plan.operations).toHaveLength(1);
      expect(plan.directoryCount).toBe(1);
      expect(warnings).toContain("Instance 'app' has no members to scaffold.");
    });

    it('operation order: directories before files for same layer', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      // Find domain dir and domain file indices
      const dirIdx = plan.operations.findIndex(
        o => o.type === OperationType.CreateDirectory && o.path.endsWith('src/domain')
      );
      const fileIdx = plan.operations.findIndex(
        o => o.type === OperationType.CreateFile && o.path.endsWith('src/domain/index.ts')
      );
      expect(dirIdx).toBeLessThan(fileIdx);
    });
  });

  describe('apply()', () => {
    it('creates directories and files when none exist', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });
      const result = service.apply(plan);

      expect(result.allSucceeded).toBe(true);
      expect(result.successCount).toBe(3); // root dir + domain dir + index.ts
      expect(result.skippedCount).toBe(0);
      expect(mockFS.directoryExists('/project/src')).toBe(true);
      expect(mockFS.directoryExists('/project/src/domain')).toBe(true);
      expect(mockFS.fileExists('/project/src/domain/index.ts')).toBe(true);
    });

    it('skips existing directories', () => {
      mockFS.withDirectory('/project/src/domain');
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });
      const result = service.apply(plan);

      expect(result.allSucceeded).toBe(true);
      const domainDirResult = result.results.find(
        r => r.operation.path === '/project/src/domain' && r.operation.type === OperationType.CreateDirectory
      );
      expect(domainDirResult!.skipped).toBe(true);
      expect(domainDirResult!.error).toBe('already exists');
    });

    it('skips existing files', () => {
      mockFS.withFile('/project/src/domain/index.ts', 'existing content');
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });
      const result = service.apply(plan);

      expect(result.allSucceeded).toBe(true);
      const fileResult = result.results.find(
        r => r.operation.path === '/project/src/domain/index.ts'
      );
      expect(fileResult!.skipped).toBe(true);
      // Verify original content preserved
      expect(mockFS.readFile('/project/src/domain/index.ts')).toBe('existing content');
    });

    it('mixed results: some created, some skipped', () => {
      mockFS.withDirectory('/project/src');
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
        { name: 'infra', location: 'src/infra' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });
      const result = service.apply(plan);

      expect(result.allSucceeded).toBe(true);
      expect(result.skippedCount).toBe(1); // /project/src already existed
      expect(result.successCount).toBe(4); // 2 dirs + 2 files created
    });

    it('files written with correct content', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });
      service.apply(plan);

      const content = mockFS.readFile('/project/src/domain/index.ts');
      expect(content).toBe('// domain layer\n// Generated by KindScript\n\nexport {};\n');
    });

    it('reports failure on write error', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'TestContext', projectRoot: '/project' });

      // Override writeFile to throw for the index.ts file
      const originalWriteFile = mockFS.writeFile.bind(mockFS);
      mockFS.writeFile = (path: string, content: string) => {
        if (path.endsWith('index.ts')) {
          throw new Error('permission denied');
        }
        originalWriteFile(path, content);
      };

      const result = service.apply(plan);

      expect(result.allSucceeded).toBe(false);
      expect(result.failureCount).toBe(1);
      const failed = result.results.find(r => !r.success);
      expect(failed).toBeDefined();
      expect(failed!.error).toBe('permission denied');
      expect(failed!.operation.path).toContain('index.ts');
    });
  });

  describe('plan() kindName', () => {
    it('stores the provided kindName on the plan', () => {
      const instance = makeInstance('app', 'src', [
        { name: 'domain', location: 'src/domain' },
      ]);

      const { plan } = service.plan({ instanceSymbol: instance, kindName: 'CleanContext', projectRoot: '/project' });

      expect(plan.instanceName).toBe('app');
      expect(plan.kindName).toBe('CleanContext');
    });
  });
});
