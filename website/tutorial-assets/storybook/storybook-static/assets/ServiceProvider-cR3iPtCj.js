import{r as a,j as f}from"./iframe-D5evrB1t.js";class c{constructor(e="/api/releases"){this.apiUrl=e}async getReleases(){const e=await fetch(this.apiUrl);if(!e.ok)throw new Error("Failed to fetch releases");return e.json()}async getRelease(e){const t=await fetch(`${this.apiUrl}/${e}`);if(!t.ok)throw new Error("Failed to fetch release");return t.json()}async createRelease(e){const t=await fetch(this.apiUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to create release");return t.json()}async create(e){return this.createRelease(e)}async updateRelease(e,t){const r=await fetch(`${this.apiUrl}/${e}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!r.ok)throw new Error("Failed to update release");return r.json()}async update(e){const{id:t,...r}=e;return this.updateRelease(t,r)}async deleteRelease(e){if(!(await fetch(`${this.apiUrl}/${e}`,{method:"DELETE"})).ok)throw new Error("Failed to delete release")}async publishRelease(e){const t=await fetch(`${this.apiUrl}/${e}/publish`,{method:"POST"});if(!t.ok)throw new Error("Failed to publish release");return t.json()}async publish(e){return this.publishRelease(e)}async getById(e){return this.getRelease(e)}async delete(e){return this.deleteRelease(e)}async getAll(e){let t=this.apiUrl;if(e){const o=new URLSearchParams;Object.entries(e).forEach(([n,i])=>{i!=null&&o.append(n,String(i))}),o.toString()&&(t+=`?${o}`)}const r=await fetch(t);if(!r.ok)throw new Error("Failed to fetch releases");return r.json()}async archiveRelease(e){const t=await fetch(`${this.apiUrl}/${e}/archive`,{method:"POST"});if(!t.ok)throw new Error("Failed to archive release");return t.json()}async archive(e){return this.archiveRelease(e)}async duplicate(e){const t=await fetch(`${this.apiUrl}/${e}/duplicate`,{method:"POST"});if(!t.ok)throw new Error("Failed to duplicate release");return t.json()}}class h{constructor(e="/api/documents"){this.apiUrl=e}async getDocuments(e){const t=new URLSearchParams;e&&Object.entries(e).forEach(([o,n])=>{n!=null&&t.append(o,String(n))});const r=await fetch(`${this.apiUrl}?${t}`);if(!r.ok)throw new Error("Failed to fetch documents");return r.json()}async getDocument(e){const t=await fetch(`${this.apiUrl}/${e}`);if(!t.ok)throw new Error("Failed to fetch document");return t.json()}async createDocument(e){const t=await fetch(this.apiUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to create document");return t.json()}async updateDocument(e,t){const r=await fetch(`${this.apiUrl}/${e}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!r.ok)throw new Error("Failed to update document");return r.json()}async deleteDocument(e){if(!(await fetch(`${this.apiUrl}/${e}`,{method:"DELETE"})).ok)throw new Error("Failed to delete document")}async getVersions(e){const t=await fetch(`${this.apiUrl}/${e}/versions`);if(!t.ok)throw new Error("Failed to fetch versions");return t.json()}async getCollaborators(e){const t=await fetch(`${this.apiUrl}/${e}/collaborators`);if(!t.ok)throw new Error("Failed to fetch collaborators");return t.json()}async shareDocument(e,t,r){if(!(await fetch(`${this.apiUrl}/${e}/share`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:t,permission:r})})).ok)throw new Error("Failed to share document")}async publishDocument(e){const t=await fetch(`${this.apiUrl}/${e}/publish`,{method:"POST"});if(!t.ok)throw new Error("Failed to publish document");return t.json()}async archiveDocument(e){const t=await fetch(`${this.apiUrl}/${e}/archive`,{method:"POST"});if(!t.ok)throw new Error("Failed to archive document");return t.json()}async restoreVersion(e,t){const r=await fetch(`${this.apiUrl}/${e}/versions/${t}/restore`,{method:"POST"});if(!r.ok)throw new Error("Failed to restore version");return r.json()}async addCollaborator(e,t,r){if(!(await fetch(`${this.apiUrl}/${e}/collaborators`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:t,role:r})})).ok)throw new Error("Failed to add collaborator")}async removeCollaborator(e,t){if(!(await fetch(`${this.apiUrl}/${e}/collaborators/${t}`,{method:"DELETE"})).ok)throw new Error("Failed to remove collaborator")}}class p{constructor(e="/api/settings"){this.apiUrl=e}async getSettings(){const e=await fetch(this.apiUrl);if(!e.ok)throw new Error("Failed to fetch settings");return e.json()}async updateProfile(e){const t=await fetch(`${this.apiUrl}/profile`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to update profile");return t.json()}async updatePreferences(e){const t=await fetch(`${this.apiUrl}/preferences`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to update preferences");return t.json()}async updateNotifications(e){const t=await fetch(`${this.apiUrl}/notifications`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to update notifications");return t.json()}async updateIntegrations(e){const t=await fetch(`${this.apiUrl}/integrations`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to update integrations");return t.json()}async updateSecurity(e){const t=await fetch(`${this.apiUrl}/security`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error("Failed to update security settings");return t.json()}async changePassword(e,t){if(!(await fetch(`${this.apiUrl}/password`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({currentPassword:e,newPassword:t})})).ok)throw new Error("Failed to change password")}async generateApiKey(e,t){const r=await fetch(`${this.apiUrl}/api-keys`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:e,permissions:t})});if(!r.ok)throw new Error("Failed to generate API key");return r.json()}async revokeApiKey(e){if(!(await fetch(`${this.apiUrl}/api-keys/${e}`,{method:"DELETE"})).ok)throw new Error("Failed to revoke API key")}async connectIntegration(e,t){if(!(await fetch(`${this.apiUrl}/integrations/${e}/connect`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)})).ok)throw new Error(`Failed to connect ${e}`)}async disconnectIntegration(e){if(!(await fetch(`${this.apiUrl}/integrations/${e}/disconnect`,{method:"POST"})).ok)throw new Error(`Failed to disconnect ${e}`)}async enableTwoFactor(){const e=await fetch(`${this.apiUrl}/security/2fa/enable`,{method:"POST"});if(!e.ok)throw new Error("Failed to enable two-factor authentication");return e.json()}async disableTwoFactor(){if(!(await fetch(`${this.apiUrl}/security/2fa/disable`,{method:"POST"})).ok)throw new Error("Failed to disable two-factor authentication")}async revokeSession(e){if(!(await fetch(`${this.apiUrl}/security/sessions/${e}/revoke`,{method:"POST"})).ok)throw new Error("Failed to revoke session")}}class d{constructor(e="/api/dashboard"){this.apiUrl=e}async getDashboardData(e){const t=new URLSearchParams;e&&Object.entries(e).forEach(([o,n])=>{n!=null&&t.append(o,String(n))});const r=await fetch(`${this.apiUrl}?${t}`);if(!r.ok)throw new Error("Failed to fetch dashboard data");return r.json()}async getStats(e){const t=e?`?timeRange=${e}`:"",r=await fetch(`${this.apiUrl}/stats${t}`);if(!r.ok)throw new Error("Failed to fetch dashboard stats");return r.json()}async getRecentActivity(e){const t=e?`?limit=${e}`:"",r=await fetch(`${this.apiUrl}/activity${t}`);if(!r.ok)throw new Error("Failed to fetch recent activity");return r.json()}async getQuickActions(){const e=await fetch(`${this.apiUrl}/quick-actions`);if(!e.ok)throw new Error("Failed to fetch quick actions");return e.json()}async getNotifications(e){const t=e?"?unreadOnly=true":"",r=await fetch(`${this.apiUrl}/notifications${t}`);if(!r.ok)throw new Error("Failed to fetch notifications");return r.json()}async markNotificationAsRead(e){if(!(await fetch(`${this.apiUrl}/notifications/${e}/read`,{method:"POST"})).ok)throw new Error("Failed to mark notification as read")}async markAllNotificationsAsRead(){if(!(await fetch(`${this.apiUrl}/notifications/read-all`,{method:"POST"})).ok)throw new Error("Failed to mark all notifications as read")}async refreshData(){const e=await fetch(`${this.apiUrl}/refresh`,{method:"POST"});if(!e.ok)throw new Error("Failed to refresh dashboard data");return e.json()}}const l=a.createContext(null);function w(){return!!(typeof window<"u"&&("__mswStarted"in window||window.location.href.includes("iframe.html")||window.parent!==window))}function u({children:s,services:e,useMocks:t=!1}){const r=a.useMemo(()=>w(),[]),o=a.useMemo(()=>r||t?{releases:new c("/api/releases"),dashboard:new d("/api/dashboard"),documents:new h("/api/documents"),settings:new p("/api/settings")}:{releases:new c("/api/releases"),dashboard:new d("/api/dashboard"),documents:new h("/api/documents"),settings:new p("/api/settings")},[r,t]);return f.jsx(l.Provider,{value:e||o,children:s})}function y(){const s=a.useContext(l);if(!s)throw new Error("useServices must be used within ServiceProvider");return s}function $(){const{releases:s}=y();return s}u.__docgenInfo={description:"",methods:[],displayName:"ServiceProvider",props:{children:{required:!0,tsType:{name:"ReactNode"},description:""},services:{required:!1,tsType:{name:"Services"},description:""},useMocks:{required:!1,tsType:{name:"boolean"},description:"",defaultValue:{value:"false",computed:!1}}}};export{u as S,$ as a,y as u};
